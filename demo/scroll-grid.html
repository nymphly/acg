<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Title</title>
  <style>
    html,
    body {
      width: 100%;
      height: 100%;
      margin: 0;
      padding: 0;
    }

    #container {
      width: 90%;
      height: 80%;
      margin: 10px;
      padding: 0;
      border: 1px solid blue;
    }

    .acg-border {
      stroke: #80cbc4;
      stroke-opacity: 100%;
      stroke-width: 1;
    }

    .acg-label {
      /* fill: white; */
      /* font-size: 1.2vmin; */
      pointer-events: none;
      /* text-shadow: black 1px 1px 0px; */
      /* text-anchor: middle; */
      font-family: Verdana, Geneva, Tahoma, sans-serif;
      alignment-baseline: middle;
    }
  </style>
  <script src='../dist/bundle.js'>
  </script>
</head>

<body>
  <h2 id="title">Rendering...</h2>
  <div id="container"></div>
</body>

<script>
  const CELL_HEIGHT = 30;
  const CELL_WIDTH = 60;

  const state = {
    xIndex: 0,
    yIndex: 0,
    xOffset: 0,
    yOffset: 0
  };

  function generateData() {
    const length = 1e3;
    // const length = 50;
    const rv = [];
    for (let i = 0; i < length; i++) {
      const xArray = [];
      rv.push(xArray);
      for (let j = 0; j < length; j++) {
        xArray.push(`${i}.${j} ACG is the so f*cking awesome`);
      }
    }
    return rv;
  }

  const data = generateData();

  const container = document.querySelector('#container');

  const config = acg.templates.svg;
  const defsConfig = {
    tag: 'defs',
    name: 'Defs'
  };

  config.content = [
    defsConfig,
    ...config.content
  ];

  const stage = acg.create(config);
  stage.container = container;

  const pather = acg.pather().setShift(0.5);

  const rootLayer = stage.find('Root-Layer');
  const defs = stage.find('Defs');

  const borderStrokeConfig = {
    tag: 'path',
    name: 'Border',
    attrs: {
      class: 'acg-border',
      d: 'M 0 0',
    },
  };

  const textsLayerConfig = {
    tag: 'g',
    name: 'Texts-Layer'
  };

  rootLayer.content = [
    textsLayerConfig,
    borderStrokeConfig
  ];

  const border = stage.find('Border');

  const resizeObserver = new ResizeObserver(entries => {
    entries.forEach((entry, index) => {
      if (entry.contentBoxSize) {
        // Firefox implements `contentBoxSize` as a single content rect, rather than an array.
        const contentBoxSize = Array.isArray(entry.contentBoxSize)
          ? entry.contentBoxSize[0]
          : entry.contentBoxSize;

        renderState(contentBoxSize.inlineSize, contentBoxSize.blockSize);
      } else {
        renderState(entry.contentRect.width, entry.contentRect.height);
      }
    });

    // const duration = Date.now() - NOW;
    // document.querySelector('#title').textContent = `First load render time: ${duration}ms`;

  });



  function renderState(width, height) {
    const textsLayer = stage.find('Texts-Layer');
    const textFactory = textsLayer.factory('Texts-Factory', {
      tag: 'text',
      attrs: {
        class: 'acg-label'
      }
    });

    const lgFactory = defs.factory('LG-Factory', {
      tag: 'linearGradient',
      attrs: {
        spreadMethod: 'pad',
        gradientUnits: 'userSpaceOnUse'
      }
    });

    textFactory.clear();
    lgFactory.clear();
    pather.clear();

    const horizontalLabelsCount = Math.ceil(width / CELL_WIDTH) + 1;
    const verticalLabelsCount = Math.ceil(height / CELL_HEIGHT) + 1;

    const xIndex = Math.max(0, Math.min(state.xIndex, data.length - horizontalLabelsCount));
    const yIndex = Math.max(0, Math.min(state.yIndex, data[0].length - verticalLabelsCount));

    let xCounter = 0;

    pather
      .moveTo(state.xOffset, state.yOffset)
      .h(width)
      .moveTo(state.xOffset, state.yOffset)
      .v(height);

    for (let i = xIndex; i < xIndex + horizontalLabelsCount; i++) {
      let yCounter = 0;
      for (let j = yIndex; j < yIndex + verticalLabelsCount; j++) {
        const text = textFactory.add({
          class: 'acg-label',
          x: state.xOffset + xCounter * CELL_WIDTH + 2,
          y: state.yOffset + yCounter * CELL_HEIGHT + CELL_HEIGHT / 2
        });

        text.content = data[i][j];
        yCounter += 1;
      }
      xCounter += 1;
    }


    xCounter = 1;
    for (let i = xIndex; i < xIndex + horizontalLabelsCount; i++) {
      pather.moveTo(state.xOffset + xCounter * CELL_WIDTH, state.yOffset).v(height);
      xCounter += 1;
    }

    let yCounter = 1;
    for (let j = yIndex; j < yIndex + verticalLabelsCount; j++) {
      pather.moveTo(state.xOffset, state.yOffset + yCounter * CELL_HEIGHT).h(width);
      yCounter += 1;
    }

    pather.applyTo(border);
    stage.render();
  }


  // const t0 = Date.now();

  // let offX = 0;
  // let offY = 0;


  // function drawState(x = 0, y = 0) {
  //   // console.log('Drawing!!!');
  //   pather.clear();
  //   let currX = x;
  //   let currY = y;

  //   const textsLayer = stage.find('Texts-Layer');
  //   const textFactory = textsLayer.factory('Texts-Factory', {
  //     tag: 'text',
  //     attrs: {
  //       'class': 'acg-label'
  //     }
  //   });
  //   textFactory.clear();

  //   const content = 'AzSxDcFvGbHnJmK,QaWsEd';
  //   const text = textFactory.add();
  //   text.attrs = {
  //     ...text.attrs,
  //     x: currX,
  //     y: 10
  //   };
  //   text.content = [
  //     {
  //       tag: 'tspan',
  //       name: `${text.name}-Tspan`,
  //       attrs: {
  //         'class': 'acg-label'
  //       },
  //       content
  //     }
  //   ];

  //   while (currX <= WIDTH) {
  //     pather.moveTo(currX, 0).v(HEIGHT);
  //     currX += CELL_WIDTH;
  //   }

  //   while (currY <= HEIGHT) {
  //     pather.moveTo(0, currY).h(WIDTH);
  //     currY += CELL_HEIGHT;
  //   }
  //   pather.applyTo(border);
  //   stage.render();
  // }

  // drawState();

  resizeObserver.observe(container);


  container.addEventListener('mousewheel', (e) => {
    e.preventDefault();

    // const dX = e.deltaX % CELL_WIDTH;
    // const dY = e.deltaY % CELL_HEIGHT;
    // offX -= dX;
    // offY -= dY;

    // drawState(offX % CELL_WIDTH, offY % CELL_HEIGHT);
  });

</script>

</html>